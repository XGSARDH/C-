# 课设报告

[TOC]

------

## 一. 需求分析

------

### 一.1 程序设计任务

本程序的任务是实现一个动态查找表，使用平衡二叉树（AVL树）作为底层数据结构。程序需要支持以下功能：

* 基本功能：关键字的查找、插入和删除操作。
* 显示功能：动态展示树结构，支持凹入表形式或图形化方式。
* 选做功能：合并两棵平衡二叉树和按值拆分平衡二叉树。

任务重点在于：

* 查找操作：从树中高效检索目标值。
* 插入操作：在保持平衡的同时插入关键字。
* 删除操作：实现平衡调整算法，重点处理平衡二叉树的删除变换。

------

### 一.2 输入的形式和范围

输入形式: 用户通过菜单界面选择操作，并输入对应的关键字值或范围值。输入值为整数，操作包括插入、查找、删除等。

输入值的范围: 输入数值应当在(*−2^15*到*2^15 − 1*)之间

------

### 一.3 输出的形式

输出的形式:字符串

------

### 一.4 程序功能

1. 查找：支持通过输入关键字查找目标节点。
2. 插入：插入关键字到树中并更新树的平衡性。
3. 删除：删除关键字后重新调整树的平衡性。
4. 树结构展示：支持凹入表或中序遍历输出。
5. 拆分树：按输入值拆分为两棵平衡二叉树。
6. 合并树：合并两棵平衡二叉树为一棵。
7. 多树管理：支持多棵平衡二叉树的创建、切换、删除和显示。

------

## 二. 概要设计

------

### 二.1 各程序文件的调用关系

`main.exe` 可执行文件

* `main.c` 是主程序文件。
* 通过链接库 `interactor` 实现功能。
* interactor是一个复合库，依赖以下模块：
  * `linked_list`：操作链表相关逻辑。
  * `menu`：菜单交互相关逻辑。
  * `avl_tree`：AVL树操作相关逻辑。

------

### 二.2 用到的所有数据类型的定义

在```status.h```中

```C
typedef enum Status
{
    STATUS_FALSE = 0,
    STATUS_TRUE = 1,
    STATUS_OVERFLOW = 2
} Status;
```

在```avl_tree.h```中

```C
// AVL 树节点数据元素类型定义
typedef int AvlElementType;

// AVL 树节点定义
typedef struct AvlNode
{
    AvlElementType data;
    int balanceFactor;
    struct AvlNode *leftChild, *rightChild;
} AvlNode, *AvlTree;

typedef enum AvlElementCompareResult
{
    // 表示左侧元素小于右侧元素
    AVLELEMENT_LESS = -1,
    // 表示两个元素相等
    AVLELEMENT_EQUAL = 0,
    // 表示左侧元素大于右侧元素
    AVLELEMENT_GREATER = 1
} AvlElementCompareResult;
```

在```linked_list.h```中

```C
// 通用链表元素类型
typedef void *ListElementType;

// 链表节点定义
typedef struct ListNode
{
    // 数据
    ListElementType data;
    // 指向下一个节点
    struct ListNode *next;
} ListNode;

// 链表定义
typedef struct LinkedList
{
    // 指向链表头节点
    ListNode *head;
    // 链表中元素个数
    int size;
} LinkedList;
```

在```menu.h```中

```C
// 菜单选项定义
typedef struct MenuOption
{
    int key;
    char *description;
    Status (*handler)(void *context);
} MenuOption;

// 菜单主体定义
typedef struct Menu
{
    char *title;
    MenuOption *option;
    int option_count;
    int display_count;
} Menu;
```

在```interactor.h```中

```C
// 定义携带信息结构体
typedef struct HandlerContext
{
    Menu *now_menu;
    Menu *top_menu;
    Menu *tree_menu;
    Menu *control_tree_menu;
    Menu *more_menu;
    LinkedList *avl_list;
    int *now_avl;
} HandlerContext;
```

------

### 二.3 主程序的流程

```markdown
1. 初始化菜单和上下文结构
   |
2. 进入主循环 (while main_status != STATUS_FALSE)
   |--> 显示当前菜单 (Menu_Display)
   |--> 等待用户输入 (fgets)
   |--> 处理用户输入 (Menu_HandlerInput)
       |--> 合法输入: 切换菜单或操作
       |--> 非法输入: 提示错误信息 (STATUS_OVERFLOW)
   |--> 等待用户按回车 (getchar)
   |--> 清屏 (ClearScreen)
   |
3. 循环结束条件满足 (main_status == STATUS_FALSE)
   |--> 显示错误信息并退出程序
```

------

## 三. 详细设计

------

### 三.1 avl_tree.h和avl_tree.c

1. 初始化AVL树
   ```C
   Status Avl_Init(AvlTree *root)
   {
       if (!root)
           return STATUS_FALSE;
       *root = NULL;
       return STATUS_TRUE;
   }
   ```

2. 初始化AVL树节点
   ```C
   /* 初始化 AVL 树节点 */
   Status AvlNode_Init(AvlTree *node, AvlElementType element)
   {
       if (!node)
           return STATUS_FALSE;
       *node = (AvlNode *)malloc(sizeof(AvlNode));
       if (!(*node))
           return STATUS_OVERFLOW;
       AvlElement_Init(&(*node)->data, element);
       (*node)->balanceFactor = 0;
       (*node)->leftChild = NULL;
       (*node)->rightChild = NULL;
       return STATUS_TRUE;
   }
   ```

3. 销毁 AVL 树
   ```C
   /* 销毁 AVL 树 */
   Status Avl_Destroy(AvlTree *root)
   {
       if (!root || !(*root))
           return STATUS_FALSE;
       Avl_Destroy(&((*root)->leftChild));
       Avl_Destroy(&((*root)->rightChild));
       free(*root);
       *root = NULL;
       return STATUS_TRUE;
   }
   ```

4. 左旋操作
   ```C
   /* 左旋操作 */
   Status Avl_RotateLeft(AvlTree *root)
   {
       if (!root || !(*root))
           return STATUS_FALSE;
       AvlTree rightChild = (*root)->rightChild;
       if (!rightChild)
           return STATUS_FALSE;
       (*root)->rightChild = rightChild->leftChild;
       rightChild->leftChild = *root;
       *root = rightChild;
       return STATUS_TRUE;
   }
   ```

5. 右旋操作
   ```C
   /* 右旋操作 */
   Status Avl_RotateRight(AvlTree *root)
   {
       if (!root || !(*root))
           return STATUS_FALSE;
       AvlTree leftChild = (*root)->leftChild;
       if (!leftChild)
           return STATUS_FALSE;
       (*root)->leftChild = leftChild->rightChild;
       leftChild->rightChild = *root;
       *root = leftChild;
       return STATUS_TRUE;
   }
   ```

6. 计算树的高度
   ```C
   // 计算树的高度
   int Avl_GetHeight(AvlTree tree)
   {
       if (tree == NULL)
       {
           return 0; // 空树高度为0
       }
       int leftHeight = Avl_GetHeight(tree->leftChild);
       int rightHeight = Avl_GetHeight(tree->rightChild);
       return 1 + (leftHeight > rightHeight ? leftHeight : rightHeight);
   }
   ```

7. 更新平衡因子
   ```C
   // 更新平衡因子（递归更新整棵树）
   Status Avl_UpdateBalanceFactor(AvlTree root)
   {
       if (root == NULL)
       {
           return STATUS_TRUE;
       }
       // 更新左右子树的平衡因子
       Avl_UpdateBalanceFactor(root->leftChild);
       Avl_UpdateBalanceFactor(root->rightChild);
   
       // 计算当前节点的平衡因子
       int leftHeight = Avl_GetHeight(root->leftChild);
       int rightHeight = Avl_GetHeight(root->rightChild);
       root->balanceFactor = leftHeight - rightHeight;
       return STATUS_TRUE;
   }
   ```

8. 插入节点

   ```C
   /* 插入节点 */
   Status Avl_Insert(AvlTree *root, AvlElementType element)
   {
       if (!root)
       {
           return STATUS_FALSE;
       }
       if (!(*root))
       {
           return AvlNode_Init(root, element);
       }
       if (AvlElement_IsEqual(element, (*root)->data) == AVLELEMENT_LESS)
       {
           if (!Avl_Insert(&((*root)->leftChild), element))
               return STATUS_FALSE;
       }
       else if (AvlElement_IsEqual(element, (*root)->data) == AVLELEMENT_GREATER)
       {
           if (!Avl_Insert(&((*root)->rightChild), element))
               return STATUS_FALSE;
       }
       else
       {
           return STATUS_FALSE; // 不允许插入重复值
       }
   
       Avl_UpdateBalanceFactor(*root);
       ;
       // 旋转保持平衡
       if ((*root)->balanceFactor > 1)
       {
           if (AvlElement_IsEqual(element, (*root)->leftChild->data) == AVLELEMENT_GREATER)
           {
               Avl_RotateLeft(&((*root)->leftChild));
               Avl_RotateRight(root);
           }
           else
           {
               Avl_RotateRight(root);
           }
       }
       else if ((*root)->balanceFactor < -1)
       {
           if (AvlElement_IsEqual(element, (*root)->rightChild->data) == AVLELEMENT_LESS)
           {
               Avl_RotateRight(&((*root)->rightChild));
               Avl_RotateLeft(root);
           }
           else
           {
               Avl_RotateLeft(root);
           }
       }
   
       return STATUS_TRUE;
   }
   ```

9. 删除节点
   ```C
   /* 删除节点 */
   Status Avl_Delete(AvlTree *root, AvlElementType element)
   {
       if (!root || !(*root))
           return STATUS_FALSE;
   
       // 递归找到目标节点并删除
       if (AvlElement_IsEqual(element, (*root)->data) == AVLELEMENT_LESS)
       {
           if (!Avl_Delete(&((*root)->leftChild), element))
               return STATUS_FALSE;
       }
       else if (AvlElement_IsEqual(element, (*root)->data) == AVLELEMENT_GREATER)
       {
           if (!Avl_Delete(&((*root)->rightChild), element))
               return STATUS_FALSE;
       }
       else
       {
           // 找到要删除的节点
           AvlTree temp = *root;
   
           // 节点有 0 个或 1 个子节点
           if (!(*root)->leftChild)
           {
               *root = (*root)->rightChild;
           }
           else if (!(*root)->rightChild)
           {
               *root = (*root)->leftChild;
           }
           else
           {
               // 节点有两个子节点，找到右子树的最小值（后继）
               AvlTree successor = (*root)->rightChild;
               while (successor->leftChild)
               {
                   successor = successor->leftChild;
               }
               // 用后继节点的值替换当前节点的值
               (*root)->data = successor->data;
               // 删除后继节点
               Avl_Delete(&((*root)->rightChild), successor->data);
               temp = NULL; // 避免误释放
           }
   
           if (temp)
               free(temp); // 释放删除的节点
       }
   
       // 如果树为空，则返回
       if (!(*root))
           return STATUS_TRUE;
   
       // 更新当前节点的平衡因子
       Avl_UpdateBalanceFactor(*root);
   
       // 平衡调整
       if ((*root)->balanceFactor > 1)
       { // 左子树过高
           if ((*root)->leftChild->balanceFactor >= 0)
           {
               Avl_RotateRight(root); // LL 型
           }
           else
           {
               Avl_RotateLeft(&((*root)->leftChild)); // LR 型
               Avl_RotateRight(root);
           }
       }
       else if ((*root)->balanceFactor < -1)
       { // 右子树过高
           if ((*root)->rightChild->balanceFactor <= 0)
           {
               Avl_RotateLeft(root); // RR 型
           }
           else
           {
               Avl_RotateRight(&((*root)->rightChild)); // RL 型
               Avl_RotateLeft(root);
           }
       }
   
       return STATUS_TRUE;
   }
   ```

10. 查找节点
    ```C
    /* 查找节点 */
    Status Avl_Search(AvlTree *root, AvlElementType element)
    {
        if (!root || !(*root))
            return STATUS_FALSE;
        AvlTree avl_tree = *root;
        if (AvlElement_IsEqual(avl_tree->data, element) == AVLELEMENT_EQUAL)
        {
            return STATUS_TRUE;
        }
        if (Avl_Search(&avl_tree->leftChild, element) == STATUS_TRUE)
        {
            return STATUS_TRUE;
        }
        if (Avl_Search(&avl_tree->rightChild, element) == STATUS_TRUE)
        {
            return STATUS_TRUE;
        }
        return STATUS_OVERFLOW;
    }
    ```

11. 打印树节点的值
    ```C
    /* 访问节点值 */
    Status Avl_VisitNode(AvlTree node)
    {
        if (!node)
        {
            return STATUS_FALSE;
        }
        AvlElement_Print(node->data);
        printf("(BF: %d)", node->balanceFactor);
        return STATUS_TRUE;
    }
    ```

12. 中序遍历

    ```C
    /* 中序遍历 */
    Status Avl_InOrderTraverse(AvlTree root)
    {
        if (!root)
            return STATUS_TRUE;
        Avl_InOrderTraverse(root->leftChild);
        AvlElement_Print(root->data);
        printf(" ");
        Avl_InOrderTraverse(root->rightChild);
        return STATUS_TRUE;
    }
    ```

13. 打印二叉树
    ```C
    /**
     * 打印 AVL 树的递归辅助函数
     * @param root 当前节点指针
     * @param depth 当前节点的深度（用于计算缩进）
     */
    void printAvlRecursive(AvlTree root, int depth)
    {
        if (!root)
            return;
    
        // 打印右子树
        printAvlRecursive(root->rightChild, depth + 1);
    
        // 打印当前节点
        for (int i = 0; i < depth; i++)
        {
            printf("       "); // 每层缩进
        }
        Avl_VisitNode(root);
        printf("\n");
    
        // 打印左子树
        printAvlRecursive(root->leftChild, depth + 1);
    }
    
    /**
     * 打印 AVL 树
     * @param root 树的根节点
     * @return Status 成功返回 STATUS_TRUE
     */
    Status Avl_PrintTree(AvlTree root)
    {
        if (!root)
            return STATUS_TRUE;     // 空树直接返回
        printAvlRecursive(root, 0); // 从根节点开始递归打印
        return STATUS_TRUE;
    }
    ```

------

### 三.2 linked_list.h和linked_list.c

1. 初始化链表
   ```C
   /* 初始化链表 */
   Status List_Init(LinkedList *list)
   {
       if (list == NULL)
           return STATUS_FALSE;
       list->head = NULL;
       list->size = 0;
       return STATUS_TRUE;
   }
   ```

2. 销毁链表
   ```C
   /* 销毁链表 */
   Status List_Destroy(LinkedList *list)
   {
       if (list == NULL)
           return STATUS_FALSE;
   
       ListNode *current = list->head;
       while (current != NULL)
       {
           ListNode *temp = current;
           current = current->next;
           free(temp);
       }
   
       list->head = NULL;
       list->size = 0;
       return STATUS_TRUE;
   }
   ```

3. 在链表尾部添加元素
   ```C
   /* 在链表尾部添加元素 */
   Status List_Append(LinkedList *list, ListElementType element)
   {
       if (list == NULL)
           return STATUS_FALSE;
   
       ListNode *newNode = (ListNode *)malloc(sizeof(ListNode));
       if (newNode == NULL)
           return STATUS_OVERFLOW;
   
       newNode->data = element;
       newNode->next = NULL;
   
       if (list->head == NULL)
       {
           // 链表为空时，直接设置新节点为头节点
           list->head = newNode;
       }
       else
       {
           // 遍历到链表尾部并添加节点
           ListNode *current = list->head;
           while (current->next != NULL)
           {
               current = current->next;
           }
           current->next = newNode;
       }
   
       list->size++;
       return STATUS_TRUE;
   }
   ```

4. 在链表指定位置插入元素
   ```C
   /* 在链表指定位置插入元素 */
   Status List_Insert(LinkedList *list, int index, ListElementType element)
   {
       if (list == NULL || index < 0 || index > list->size)
           return STATUS_FALSE;
   
       ListNode *newNode = (ListNode *)malloc(sizeof(ListNode));
       if (newNode == NULL)
           return STATUS_OVERFLOW;
   
       newNode->data = element;
   
       if (index == 0)
       {
           // 在头部插入
           newNode->next = list->head;
           list->head = newNode;
       }
       else
       {
           // 遍历到指定位置前一个节点
           ListNode *current = list->head;
           for (int i = 0; i < index - 1; i++)
           {
               current = current->next;
           }
           newNode->next = current->next;
           current->next = newNode;
       }
   
       list->size++;
       return STATUS_TRUE;
   }
   ```

5. 删除链表指定位置的元素
   ```C
   /* 删除链表指定位置的元素 */
   Status List_RemoveAt(LinkedList *list, int index, ListElementType *element)
   {
       if (list == NULL || index < 0 || index >= list->size)
           return STATUS_FALSE;
   
       ListNode *toDelete;
       if (index == 0)
       {
           // 删除头节点
           toDelete = list->head;
           list->head = toDelete->next;
       }
       else
       {
           // 遍历到指定位置前一个节点
           ListNode *current = list->head;
           for (int i = 0; i < index - 1; i++)
           {
               current = current->next;
           }
           toDelete = current->next;
           current->next = toDelete->next;
       }
   
       if (element != NULL)
       {
           *element = toDelete->data;
       }
   
       free(toDelete);
       list->size--;
       return STATUS_TRUE;
   }
   ```

6. 获取链表指定位置的元素
   ```C
   /* 获取链表指定位置的元素 */
   Status List_Get(LinkedList *list, int index, ListElementType *element)
   {
       if (list == NULL || index < 0 || index >= list->size)
           return STATUS_FALSE;
   
       ListNode *current = list->head;
       for (int i = 0; i < index; i++)
       {
           current = current->next;
       }
   
       // if (element != NULL) {
       //     *element = current->data;
       // }
       *element = current->data;
       return STATUS_TRUE;
   }
   ```

7. 改变指定位置的链表元素值
   ```C
   /* 改变指定位置的链表元素值 */
   Status List_Change(LinkedList *list, int index, ListElementType *element)
   {
       if (list == NULL || index < 0 || index >= list->size)
           return STATUS_FALSE;
       ListNode *current = list->head;
       for (int i = 0; i < index; i++)
       {
           current = current->next;
       }
       current->data = *element;
       return STATUS_TRUE;
   }
   ```

8. 获取链表大小
   ```C
   /* 获取链表大小 */
   int List_Size(LinkedList *list)
   {
       if (list == NULL)
           return 0;
       return list->size;
   }
   ```

9. 判断链表是否为空
   ```C
   /* 判断链表是否为空 */
   Status List_IsEmpty(LinkedList *list)
   {
       if (list == NULL)
           return STATUS_TRUE;
       return (list->size == 0) ? STATUS_TRUE : STATUS_FALSE;
   }
   ```

------

### 三.3 menu.h和menu.c

1. 创建menu菜单
   ```C
   // 创建menu菜单
   Status Menu_Create(Menu *menu, char **title, MenuOption *option, int option_count, int display_count)
   {
       if (!menu)
       {
           return STATUS_FALSE;
       }
       menu->title = *title;
       menu->option = option;
       menu->option_count = option_count;
       menu->display_count = display_count;
       return STATUS_TRUE;
   }
   ```

2. 菜单赋值
   ```C
   // 菜单赋值
   Status Menu_UpdateByMenu(Menu *menu_changed, Menu *menu_purpose)
   {
       if (!menu_purpose || !menu_changed)
       {
           return STATUS_FALSE;
       }
       *menu_changed = *menu_purpose;
       return STATUS_TRUE;
   }
   ```

3. 打印菜单
   ```C
   // 打印菜单
   Status Menu_Display(Menu *menu)
   {
       printf("%s\n", menu->title); // 打印标题
       for (int i = 0; i < menu->display_count && i < menu->option_count; i++)
       {
           printf("%d. %s\n", menu->option[i].key, menu->option[i].description);
       }
   
       return STATUS_TRUE;
   }
   ```

4. 更新menu菜单中的选项和项数
   ```C
   // 更新menu菜单中的选项和项数
   Status Menu_UpdateOption(Menu *menu, MenuOption *option, int option_count)
   {
       if (!menu)
       {
           return STATUS_FALSE;
       }
       menu->option = option;
       menu->option_count = option_count;
       return STATUS_TRUE;
   }
   ```

5. 创建菜单选项
   ```C
   // 创建菜单选项
   Status MenuOption_create(MenuOption *menuOption, int key, char *description, Status (*handler)(void *context))
   {
       if (!menuOption)
       {
           return STATUS_FALSE;
       }
       menuOption->key = key;
       menuOption->description = description;
       menuOption->handler = handler;
       return STATUS_TRUE;
   }
   ```

6. 处理菜单输入
   ```C
   // 处理菜单输入
   Status Menu_HandlerInput(Menu menu, char *input_option, void *context)
   {
       // 检查输入是否为空
       if (input_option == NULL || strlen(input_option) == 0)
       {
           return STATUS_OVERFLOW; // 输入为空，返回失败
       }
       // 检查输入是否为纯数字
       if (is_number(input_option) == STATUS_FALSE)
       {
           return STATUS_OVERFLOW; // 输入中有非数字字符
       }
       if (strlen(input_option) > 5)
       {
           return STATUS_OVERFLOW; // 输入超过范围
       }
       // 将输入字符串转换为数字
       int option = strtol(input_option, NULL, 10);
       if (option < 0 || option >= menu.option_count)
       {
           return STATUS_OVERFLOW; // 输入不合法
       }
       return menu.option[option].handler(context);
   }
   ```

------

### 三.4 interactor.h和interactor.c

1. 清屏函数
   ```C
   void ClearScreen()
   {
   #ifdef _WIN32
       system("cls"); // Windows 平台
   #else
       system("clear"); // Linux/Unix 平台
   #endif
   }
   ```

2. 判断字符串是否为数字
   ```C
   Status Interactor_IsNumber(const char *str)
   {
       if (str == NULL || *str == '\0')
       {
           return STATUS_FALSE; // 空字符串或 NULL 非法
       }
       while (*str)
       {
           if (!isdigit(*str))
           {
               return STATUS_FALSE; // 非数字字符
           }
           str++;
       }
       return STATUS_TRUE;
   }
   ```

3. 将输入字符串作合法判断
   ```C
   Status Helper_CharInputAndOutputInt(int *output)
   {
       char input_num[MAX_INPUT];
       if (fgets(input_num, sizeof(input_num), stdin) != NULL)
       {
           // 去掉换行符
           input_num[strcspn(input_num, "\n")] = '\0';
       }
       // 检查输入是否为纯数字
       if (Interactor_IsNumber(input_num) == STATUS_FALSE)
       {
           return STATUS_OVERFLOW; // 输入中有非数字字符
       }
       if (strlen(input_num) > 5)
       {
           return STATUS_TRUE; // 输入超过范围
       }
       // 将输入字符串转换为数字
       int number = strtol(input_num, NULL, 10);
       *output = number;
       return STATUS_TRUE;
   }
   ```

4. 响应体初始化
   ```C
   Status HandlerContext_Init(HandlerContext *handler_context, Menu *now_menu, Menu *top_menu, Menu *tree_menu,
                              Menu *control_tree_menu, Menu *more_menu, LinkedList *avl_list, int *now_avl)
   {
       if (!handler_context || !top_menu || !avl_list || !now_avl || !tree_menu || !control_tree_menu || !more_menu)
       {
           return STATUS_FALSE;
       }
       handler_context->top_menu = top_menu;
       handler_context->now_menu = now_menu;
       handler_context->tree_menu = tree_menu;
       handler_context->control_tree_menu = control_tree_menu;
       handler_context->more_menu = more_menu;
       handler_context->avl_list = avl_list;
       handler_context->now_avl = now_avl;
       return STATUS_TRUE;
   }
   ```

5. 顶级菜单 - 退出程序

   ```C
   /* 顶级菜单 - 退出程序 */
   Status top_menu_handler0(void *context)
   {
       HandlerContext *handler_context = (HandlerContext *)context;
   
       while (List_Size(handler_context->avl_list) > 0) {
           ListElementType get_avl_tree_origin;
           if (STATUS_FALSE == List_RemoveAt(handler_context->avl_list, 0, &get_avl_tree_origin))
           {
               *handler_context->now_avl = -1;
               continue;
           }
           AvlTree avl_tree = (AvlTree)get_avl_tree_origin;
           if (get_avl_tree_origin == NULL)
           {
               continue;
           }
           Status status = Avl_Destroy(&avl_tree);
       }
       exit(0);
   }
   ```

6. 顶级菜单 - 创建一棵新平衡二叉树

   ```C
   /* 顶级菜单 - 创建一棵新平衡二叉树 */
   Status top_menu_handler1(void *context)
   {
       HandlerContext *handler_context = (HandlerContext *)context;
       Status output_status = List_Append(handler_context->avl_list, NULL);
       if (output_status == STATUS_TRUE)
       {
           printf("创建成功\n");
           return output_status;
       }
       else
       {
           printf("创建失败\n");
           return output_status;
       }
   }
   ```

7. 顶级菜单 - 对二叉树进行调整

   ```C
   /* 顶级菜单 - 对二叉树进行调整 */
   Status top_menu_handler2(void *context)
   {
       HandlerContext *handler_context = (HandlerContext *)context;
       handler_context->now_menu = handler_context->tree_menu;
       return STATUS_TRUE;
   }
   ```

8. 顶级菜单 - 更多功能

   ```C
   /* 顶级菜单 - 更多功能 */
   Status top_menu_handler3(void *context)
   {
       if (!context)
       {
           return STATUS_FALSE;
       }
       HandlerContext *handler_context = (HandlerContext *)context;
       handler_context->now_menu = handler_context->more_menu;
       return STATUS_TRUE;
   }
   ```

9. 顶级菜单 - 自动生成一棵包含所有从起始值到结束值（包括边界值）的平衡二叉树

   ```C
   /* 顶级菜单 - 自动生成一棵包含所有从起始值到结束值（包括边界值）的平衡二叉树 */
   Status top_menu_handler4(void *context)
   {
       HandlerContext *handler_context = (HandlerContext *)context;
       printf("输入起始值: ");
       int number1 = -1;
       if (Helper_CharInputAndOutputInt(&number1) != STATUS_TRUE)
       {
           printf("输入不是纯数字\n");
           return STATUS_OVERFLOW;
       }
       printf("输入结束值: ");
       int number2 = -1;
       if (Helper_CharInputAndOutputInt(&number2) != STATUS_TRUE)
       {
           printf("输入不是纯数字\n");
           return STATUS_OVERFLOW;
       }
       if(number1 > number2) {
           printf("起始值应大于等于结束值");
           return STATUS_OVERFLOW; // 输入不合法
       }
       AvlTree avl_tree = NULL;
       Avl_Init(&avl_tree);
       Status output_status = STATUS_TRUE;
       for(int insert_number = number1; insert_number <= number2; insert_number++) {
           output_status = Avl_Insert(&avl_tree, insert_number);
       }
       if (output_status == STATUS_TRUE)
       {
           printf("生成成功\n");
       }
       else
       {
           printf("生成失败\n");
       }
       printf("\n生成结果: \n");
       Avl_PrintTree(avl_tree);
   
       ListElementType curr = NULL;
       curr = (ListElementType *)avl_tree;
       List_Append(handler_context->avl_list, curr);
       return output_status;
   }
   ```

10. 控制二叉树菜单 - 返回选择二叉树菜单

   ```C
   /* 控制二叉树菜单 - 返回选择二叉树菜单 */
   Status control_tree_menu_handler0(void *context)
   {
       if (!context)
       {
           return STATUS_FALSE;
       }
       HandlerContext *handler_context = (HandlerContext *)context;
       handler_context->now_menu = handler_context->tree_menu;
       return STATUS_TRUE;
   }
   ```

11. 控制二叉树菜单 - 插入数值

    ```c
    /* 控制二叉树菜单 - 插入数值 */
    Status control_tree_menu_handler1(void *context)
    {
        HandlerContext *handler_context = (HandlerContext *)context;
        ListElementType get_avl_tree_origin;
        if (STATUS_FALSE == List_Get(handler_context->avl_list, *handler_context->now_avl, &get_avl_tree_origin))
        {
            control_tree_menu_handler0(context);
            *handler_context->now_avl = -1;
            return STATUS_FALSE;
        }
        int insert_value = 0;
        printf("输入要添加的数字: ");
        if (Helper_CharInputAndOutputInt(&insert_value) != STATUS_TRUE)
        {
            printf("输入不是纯数字\n");
            return STATUS_OVERFLOW;
        }
        if (abs(insert_value) > 65533)
        {
            printf("输入数字绝对值过大\n");
            return STATUS_OVERFLOW;
        }
        AvlTree avl_tree = (AvlTree)get_avl_tree_origin;
        if (get_avl_tree_origin == NULL)
        {
            AvlTree purpose = NULL;
            Avl_Init(&purpose);
            avl_tree = purpose;
        }
        Avl_Insert(&avl_tree, insert_value);
        ListElementType curr = (ListElementType *)avl_tree;
        List_Change(handler_context->avl_list, *handler_context->now_avl, &curr);
        return STATUS_TRUE;
    }
    ```

12. 控制二叉树菜单 - 删除数值

    ```c
    /*控制二叉树菜单 - 删除数值  */
    Status control_tree_menu_handler2(void *context)
    {
        HandlerContext *handler_context = (HandlerContext *)context;
        ListElementType get_avl_tree_origin;
        if (STATUS_FALSE == List_Get(handler_context->avl_list, *handler_context->now_avl, &get_avl_tree_origin))
        {
            control_tree_menu_handler0(context);
            *handler_context->now_avl = -1;
            return STATUS_FALSE;
        }
        int insert_value = 0;
        printf("输入要删除的数字: ");
        if (Helper_CharInputAndOutputInt(&insert_value) != STATUS_TRUE)
        {
            printf("输入不是纯数字\n");
            return STATUS_OVERFLOW;
        }
        if (abs(insert_value) > 65533)
        {
            printf("输入数字绝对值过大\n");
            return STATUS_OVERFLOW;
        }
        AvlTree avl_tree = (AvlTree)get_avl_tree_origin;
        if (get_avl_tree_origin == NULL)
        {
            printf("该树现在为空树, 无法执行该操作.\n");
            return STATUS_OVERFLOW;
        }
        Status delete_status = Avl_Delete(&avl_tree, insert_value);
        if (delete_status == STATUS_FALSE)
        {
            printf("该树不存在该值, 无法执行该操作.\n");
            return STATUS_OVERFLOW;
        }
        ListElementType curr = (ListElementType *)avl_tree;
        List_Change(handler_context->avl_list, *handler_context->now_avl, &curr);
        return STATUS_TRUE;
    }
    ```

13. 控制二叉树菜单 - 查找数值

    ```c
    /* 控制二叉树菜单 - 查找数值 */
    Status control_tree_menu_handler3(void *context)
    {
        HandlerContext *handler_context = (HandlerContext *)context;
        ListElementType get_avl_tree_origin;
        if (STATUS_FALSE == List_Get(handler_context->avl_list, *handler_context->now_avl, &get_avl_tree_origin))
        {
            control_tree_menu_handler0(context);
            *handler_context->now_avl = -1;
            return STATUS_FALSE;
        }
        int insert_value = 0;
        printf("输入要删除的数字: ");
        if (Helper_CharInputAndOutputInt(&insert_value) != STATUS_TRUE)
        {
            printf("输入不是纯数字\n");
            return STATUS_OVERFLOW;
        }
        if (abs(insert_value) > 65533)
        {
            printf("输入数字绝对值过大\n");
            return STATUS_OVERFLOW;
        }
        AvlTree avl_tree = (AvlTree)get_avl_tree_origin;
        if (get_avl_tree_origin == NULL)
        {
            printf("该树现在为空树, 无法执行该操作.\n");
            return STATUS_OVERFLOW;
        }
        Status delete_status = Avl_Search(&avl_tree, insert_value);
        if (delete_status == STATUS_OVERFLOW)
        {
            printf("该树不存在该值\n");
            return STATUS_OVERFLOW;
        }
        else
        {
            printf("该树存在该值 %d \n", insert_value);
        }
        return STATUS_TRUE;
    }
    ```

14. 控制二叉树菜单 - 打印二叉树

    ```c
    /* 控制二叉树菜单 - 打印二叉树 */
    Status control_tree_menu_handler4(void *context)
    {
        HandlerContext *handler_context = (HandlerContext *)context;
        ListElementType get_avl_tree_origin;
        if (STATUS_FALSE == List_Get(handler_context->avl_list, *handler_context->now_avl, &get_avl_tree_origin))
        {
            control_tree_menu_handler0(context);
            *handler_context->now_avl = -1;
            return STATUS_FALSE;
        }
        AvlTree avl_tree = (AvlTree)get_avl_tree_origin;
        if (get_avl_tree_origin == NULL)
        {
            printf("该树现在为空树.\n");
            return STATUS_TRUE;
        }
        Status status = Avl_PrintTree(avl_tree);
        return STATUS_TRUE;
    }
    ```

15. 控制二叉树菜单 - 中序遍历

    ```c
    /* 控制二叉树菜单 - 中序遍历 */
    Status control_tree_menu_handler5(void *context)
    {
        HandlerContext *handler_context = (HandlerContext *)context;
        ListElementType get_avl_tree_origin;
        if (STATUS_FALSE == List_Get(handler_context->avl_list, *handler_context->now_avl, &get_avl_tree_origin))
        {
            control_tree_menu_handler0(context);
            *handler_context->now_avl = -1;
            return STATUS_FALSE;
        }
        AvlTree avl_tree = (AvlTree)get_avl_tree_origin;
        if (get_avl_tree_origin == NULL)
        {
            printf("该树现在为空树.\n");
            return STATUS_TRUE;
        }
        Status status = Avl_InOrderTraverse(avl_tree);
        printf("\n");
        return STATUS_TRUE;
    }
    ```

16. 控制二叉树菜单 - 以某值为界限拆分二叉树

    ```c
    /* 控制二叉树菜单 - 以某值为界限拆分二叉树 */
    Status control_tree_menu_handler6(void *context)
    {
        HandlerContext *handler_context = (HandlerContext *)context;
        ListElementType get_avl_tree_origin;
        if (STATUS_FALSE == List_Get(handler_context->avl_list, *handler_context->now_avl, &get_avl_tree_origin))
        {
            control_tree_menu_handler0(context);
            *handler_context->now_avl = -1;
            return STATUS_FALSE;
        }
        int insert_value = 0;
        printf("输入要作为分割两个平衡二叉树的数字: ");
        if (Helper_CharInputAndOutputInt(&insert_value) != STATUS_TRUE)
        {
            printf("输入不是纯数字\n");
            return STATUS_OVERFLOW;
        }
        if (abs(insert_value) > 65533)
        {
            printf("输入数字绝对值过大\n");
            return STATUS_OVERFLOW;
        }
        AvlTree avl_tree = (AvlTree)get_avl_tree_origin;
        if (get_avl_tree_origin == NULL)
        {
            AvlTree purpose = NULL;
            Avl_Init(&purpose);
            avl_tree = purpose;
        }
        AvlTree spilt_tree1 = NULL;
        AvlTree spilt_tree2 = NULL;
        Avl_Split(&avl_tree, insert_value, &spilt_tree1, &spilt_tree2);
        // ListElementType curr = (ListElementType*)avl_tree;
        printf("分割成功\n");
        printf("分割的第1棵树:\n");
        Avl_PrintTree(spilt_tree1);
        printf("分割的第2棵树:\n");
        Avl_PrintTree(spilt_tree2);
    
        ListElementType curr = NULL;
        curr = (ListElementType *)spilt_tree1;
        List_Append(handler_context->avl_list, curr);
        curr = (ListElementType *)spilt_tree2;
        List_Append(handler_context->avl_list, curr);
    
        return STATUS_TRUE;
    }
    ```

17. 控制二叉树菜单 - 删除该树

    ```c
    /* 控制二叉树菜单 - 删除该树 */
    Status control_tree_menu_handler7(void *context) {
        HandlerContext *handler_context = (HandlerContext *)context;
        ListElementType get_avl_tree_origin;
        handler_context->now_menu = handler_context->tree_menu;
        if (STATUS_FALSE == List_RemoveAt(handler_context->avl_list, *handler_context->now_avl, &get_avl_tree_origin))
        {
            control_tree_menu_handler0(context);
            *handler_context->now_avl = -1;
            return STATUS_FALSE;
        }
        AvlTree avl_tree = (AvlTree)get_avl_tree_origin;
        if (get_avl_tree_origin == NULL)
        {
            return STATUS_TRUE;
        }
        Status status = Avl_Destroy(&avl_tree);
        return STATUS_TRUE;
    }
    ```

18. 选择二叉树菜单 - 返回顶级目录

    ```c
    /* 选择二叉树菜单 - 返回顶级目录 */
    Status tree_menu_handler0(void *context)
    {
        HandlerContext *handler_context = (HandlerContext *)context;
        handler_context->now_menu = handler_context->top_menu;
        return STATUS_TRUE;
    }
    ```

19. 选择二叉树菜单 - 跳转到指定序号平衡二叉树调整菜单

    ```c
    /* 选择二叉树菜单 - 跳转到指定序号平衡二叉树调整菜单 */
    Status tree_menu_handler1(void *context)
    {
        HandlerContext *handler_context = (HandlerContext *)context;
        printf("输入您要查看的二叉树对应的序号: ");
        int number = -1;
        if (Helper_CharInputAndOutputInt(&number) != STATUS_TRUE)
        {
            printf("输入不是纯数字\n");
            return STATUS_OVERFLOW;
        }
        if (number < 1 || number > List_Size(handler_context->avl_list))
        {
            printf("输出超出范围");
            return STATUS_OVERFLOW; // 输入不合法
        }
        *handler_context->now_avl = number - 1;
        handler_context->now_menu = handler_context->control_tree_menu;
        return STATUS_TRUE;
    }
    ```

20. 选择二叉树菜单 - 查看当前二叉树数量

    ```c
    /* 选择二叉树菜单 - 查看当前二叉树数量 */
    Status tree_menu_handler2(void *context)
    {
        HandlerContext *handler_context = (HandlerContext *)context;
        printf("当前共有二叉树数量为 %d \n", List_Size(handler_context->avl_list));
        return STATUS_TRUE;
    }
    ```

21. 更多功能菜单 - 返回顶级目录

    ```c
    /* 更多功能菜单 - 返回顶级目录 */
    Status more_menu_handler0(void *context)
    {
        HandlerContext *handler_context = (HandlerContext *)context;
        handler_context->now_menu = handler_context->top_menu;
        return STATUS_TRUE;
    }
    ```

22. 更多功能菜单 - 打印指定编号的二叉树

    ```c
    /* 更多功能菜单 - 打印指定编号的二叉树 */
    Status more_menu_handler1(void *context)
    {
        HandlerContext *handler_context = (HandlerContext *)context;
        printf("输入您要查看的二叉树对应的序号: ");
        int number = -1;
        if (Helper_CharInputAndOutputInt(&number) != STATUS_TRUE)
        {
            printf("输入不是纯数字\n");
            return STATUS_OVERFLOW;
        }
        if (number < 1 || number > List_Size(handler_context->avl_list))
        {
            printf("输出超出范围");
            return STATUS_OVERFLOW; // 输入不合法
        }
        *handler_context->now_avl = number - 1;
        return control_tree_menu_handler4(context);
    }
    ```

23. 更多功能菜单 - 合并指定两个编号的二叉树

    ```c
    /* 更多功能菜单 - 合并指定两个编号的二叉树 */
    Status more_menu_handler2(void *context)
    {
        HandlerContext *handler_context = (HandlerContext *)context;
        printf("输入您要合并的第1棵二叉树对应的序号: ");
        int number1 = -1;
        if (Helper_CharInputAndOutputInt(&number1) != STATUS_TRUE)
        {
            printf("输入不是纯数字\n");
            return STATUS_OVERFLOW;
        }
        if (number1 < 1 || number1 > List_Size(handler_context->avl_list))
        {
            printf("输出超出范围");
            return STATUS_OVERFLOW; // 输入不合法
        }
        printf("输入您要合并的第2棵二叉树对应的序号: ");
        int number2 = -1;
        if (Helper_CharInputAndOutputInt(&number2) != STATUS_TRUE)
        {
            printf("输入不是纯数字\n");
            return STATUS_OVERFLOW;
        }
        if (number2 < 1 || number2 > List_Size(handler_context->avl_list))
        {
            printf("输出超出范围");
            return STATUS_OVERFLOW; // 输入不合法
        }
        ListElementType get_avl_tree_origin_1;
        if (STATUS_FALSE == List_Get(handler_context->avl_list, number1 - 1, &get_avl_tree_origin_1))
        {
            control_tree_menu_handler0(context);
            return STATUS_FALSE;
        }
        ListElementType get_avl_tree_origin_2;
        if (STATUS_FALSE == List_Get(handler_context->avl_list, number2 - 1, &get_avl_tree_origin_2))
        {
            control_tree_menu_handler0(context);
            return STATUS_FALSE;
        }
        AvlTree avl_tree_1 = (AvlTree)get_avl_tree_origin_1;
        AvlTree avl_tree_2 = (AvlTree)get_avl_tree_origin_2;
        AvlTree purpose_tree = NULL;
    
        Status output_status = Avl_Merge(&avl_tree_1, &avl_tree_2, &purpose_tree);
        if (output_status == STATUS_TRUE)
        {
            printf("合并成功\n");
        }
        else
        {
            printf("合并失败\n");
        }
    
        printf("\n参与合并的第1棵树: \n");
        Avl_PrintTree(avl_tree_1);
        printf("\n参与合并的第2棵树: \n");
        Avl_PrintTree(avl_tree_2);
        printf("\n合并结果: \n");
        Avl_PrintTree(purpose_tree);
    
        ListElementType curr = NULL;
        curr = (ListElementType *)purpose_tree;
        List_Append(handler_context->avl_list, curr);
    
        return output_status;
    }
    ```

24. 更多功能菜单 - 查看当前二叉树的数量

    ```c
    /* 更多功能菜单 - 查看当前二叉树的数量 */
    Status more_menu_handler3(void *context)
    {
        HandlerContext *handler_context = (HandlerContext *)context;
        printf("当前共有二叉树数量为 %d \n", List_Size(handler_context->avl_list));
        return STATUS_TRUE;
    }
    
    /* 顶部菜单及选项初始化 */
    Status Top_Menu_Init(Menu *top_menu, MenuOption *top_menu_option)
    {
        MenuOption_create(&top_menu_option[0], 0, "退出程序", top_menu_handler0);
        MenuOption_create(&top_menu_option[1], 1, "创建一棵新平衡二叉树", top_menu_handler1);
        MenuOption_create(&top_menu_option[2], 2, "选择二叉树进行调整", top_menu_handler2);
        MenuOption_create(&top_menu_option[3], 3, "更多功能", top_menu_handler3);
        MenuOption_create(&top_menu_option[4], 4, "自动生成一棵包含所有从起始值到结束值（包括边界值）的平衡二叉树", top_menu_handler4);
        char *top_menu_title = "顶级菜单";
        Menu_Create(top_menu, &top_menu_title, top_menu_option, TOP_MENU_COUNT, TOP_MENU_COUNT);
        return STATUS_TRUE;
    }
    ```

25. 控制二叉树菜单及选项初始化

    ```c
    /* 控制二叉树菜单及选项初始化 */
    Status Control_Tree_Menu_Init(Menu *control_tree_menu, MenuOption *control_tree_menu_option)
    {
        MenuOption_create(&control_tree_menu_option[0], 0, "返回选择二叉树菜单", control_tree_menu_handler0);
        MenuOption_create(&control_tree_menu_option[1], 1, "插入数值", control_tree_menu_handler1);
        MenuOption_create(&control_tree_menu_option[2], 2, "删除数值", control_tree_menu_handler2);
        MenuOption_create(&control_tree_menu_option[3], 3, "查找数值", control_tree_menu_handler3);
        MenuOption_create(&control_tree_menu_option[4], 4, "打印二叉树", control_tree_menu_handler4);
        MenuOption_create(&control_tree_menu_option[5], 5, "中序遍历", control_tree_menu_handler5);
        MenuOption_create(&control_tree_menu_option[6], 6, "以某值为界限拆分二叉树", control_tree_menu_handler6);
        MenuOption_create(&control_tree_menu_option[7], 7, "删除该树", control_tree_menu_handler7);
        char *control_tree_menu_title = "单棵平衡二叉树调整菜单";
        Menu_Create(control_tree_menu, &control_tree_menu_title, control_tree_menu_option, CONTROL_TREE_MENU_COUNT,
                    CONTROL_TREE_MENU_COUNT);
        return STATUS_TRUE;
    }
    ```

26. 选择二叉树菜单及选项初始化

    ```c
    /* 选择二叉树菜单及选项初始化 */
    Status Tree_Menu_Init(Menu *tree_menu, MenuOption *tree_menu_option)
    {
        MenuOption_create(&tree_menu_option[0], 0, "返回顶级目录", tree_menu_handler0);
        MenuOption_create(&tree_menu_option[1], 1, "跳转到指定序号平衡二叉树调整菜单", tree_menu_handler1);
        MenuOption_create(&tree_menu_option[2], 2, "查看当前二叉树数量", tree_menu_handler2);
        char *tree_menu_title = "选择二叉树菜单";
        Menu_Create(tree_menu, &tree_menu_title, tree_menu_option, TREE_MENU_COUNT, TREE_MENU_COUNT);
        return STATUS_TRUE;
    };
    ```

27. 更多功能菜单及选项初始化

    ```c
    /* 更多功能菜单及选项初始化 */
    Status More_Menu_Init(Menu *more_menu, MenuOption *more_menu_option)
    {
        MenuOption_create(&more_menu_option[0], 0, "返回顶级目录", more_menu_handler0);
        MenuOption_create(&more_menu_option[1], 1, "打印指定编号的二叉树", more_menu_handler1);
        MenuOption_create(&more_menu_option[2], 2, "合并指定两个编号的二叉树", more_menu_handler2);
        MenuOption_create(&more_menu_option[3], 3, "查看当前二叉树的数量", more_menu_handler3);
        char *more_menu_title = "更多功能菜单";
        Menu_Create(more_menu, &more_menu_title, more_menu_option, MORE_MENU_COUNT, MORE_MENU_COUNT);
        return STATUS_TRUE;
    };
    ```

------

### 三.5 main.c

主程序执行

```c
#define TOP_MENU_COUNT 5
#define TREE_MENU_COUNT 3
#define CONTROL_TREE_MENU_COUNT 8
#define MORE_MENU_COUNT 4
#define MAX_INPUT 100

int main()
{
    // 定义变量
    Menu top_menu, tree_menu, control_tree_menu, more_menu;
    MenuOption top_menu_option[TOP_MENU_COUNT];
    MenuOption tree_menu_option[TREE_MENU_COUNT];
    MenuOption control_tree_menu_option[CONTROL_TREE_MENU_COUNT];
    MenuOption more_menu_option[MORE_MENU_COUNT];
    LinkedList avl_list;
    int now_avl_position = -1;
    Menu now_menu;
    HandlerContext context;

    // 初始化变量
    List_Init(&avl_list);
    Top_Menu_Init(&top_menu, top_menu_option);
    Tree_Menu_Init(&tree_menu, tree_menu_option);
    Control_Tree_Menu_Init(&control_tree_menu, control_tree_menu_option);
    More_Menu_Init(&more_menu, more_menu_option);
    HandlerContext_Init(&context, &now_menu, &top_menu, &tree_menu, &control_tree_menu, &more_menu, &avl_list,
                        &now_avl_position);
    now_menu = top_menu;

    // 开始程序
    Status main_status = STATUS_TRUE;
    char input_choose[MAX_INPUT] = {};
    while (main_status != STATUS_FALSE)
    {
        Menu_Display(context.now_menu);
        printf("\n请输入选择: ");
        if (fgets(input_choose, sizeof(input_choose), stdin) != NULL)
        {
            // 去掉换行符
            input_choose[strcspn(input_choose, "\n")] = '\0';
        }
        main_status = Menu_HandlerInput(*context.now_menu, input_choose, &context);
        if(main_status == STATUS_OVERFLOW) {
            printf("\n您的输入不合法, 请输入指定选项的数字\n");
        }
        printf("按回车以继续\n");
        getchar();
        ClearScreen();
    }
    printf("程序发生错误, 即将终止");
    getchar();
    return 0;
}
```

### 三.6 函数和过程的调用关系图

1. 主函数入口
   ```txt
   main
       ├── List_Init
       │       ├── 初始化 AVL 树的链表
       ├── Top_Menu_Init
       │       ├── 初始化顶层菜单及选项
       ├── Tree_Menu_Init
       │       ├── 初始化树菜单及选项
       ├── Control_Tree_Menu_Init
       │       ├── 初始化控制树菜单及选项
       ├── More_Menu_Init
       │       ├── 初始化更多功能菜单及选项
       ├── HandlerContext_Init
       │       ├── 初始化上下文，绑定菜单、树列表及当前选择
       │       └── 设置当前菜单为 `top_menu`
       ├── 循环逻辑 (while main_status != STATUS_FALSE)
       │       ├── Menu_Display
       │       │       ├── 显示当前菜单内容
       │       ├── 用户输入逻辑
       │       │       ├── fgets
       │       │       ├── 去掉换行符
       │       ├── Menu_HandlerInput
       │       │       ├── 处理用户输入
       │       │       ├── 根据输入跳转到不同的菜单或调用对应功能
       │       │       └── 如果输入无效，返回 `STATUS_OVERFLOW`
       │       ├── 错误处理
       │       │       ├── 检查 main_status 是否为 `STATUS_OVERFLOW`
       │       │       └── 提示用户输入无效
       │       ├── getchar
       │       │       ├── 暂停，等待用户按回车继续
       │       ├── ClearScreen
       │       │       ├── 清屏显示，刷新界面
       ├── 错误提示
       │       ├── 当主状态为 `STATUS_FALSE` 时，提示错误并终止程序
       └── 返回 0
   ```

2. 初始化顶层菜单及选项

   ```txt
   Top_Menu_Init
       ├── MenuOption_create (×5)
       │       ├── 创建菜单选项
       │       ├── 参数：
       │       │   ├── 菜单选项数组
       │       │   ├── 菜单项编号
       │       │   ├── 菜单项描述
       │       │   └── 菜单项对应的处理函数
       │       ├── 处理函数：
       │       │   ├── 退出程序
       │       │   ├── 创建一棵新平衡二叉树
       │       │   ├── 选择二叉树进行调整
       │       │   ├── 更多功能
       │       │   └── 自动生成一棵包含所有从起始值到结束值（包括边界值）的平衡二叉树
       ├── Menu_Create
       │       ├── 创建菜单结构
       │       ├── 参数：
       │       │   ├── 菜单结构指针
       │       │   ├── 菜单标题
       │       │   ├── 菜单选项数组
       │       │   ├── 菜单选项数量
       │       │   └── 最大选项数量
       └── 返回 STATUS_TRUE
   ```

3. 初始化控制树菜单及选项

   ```txt
   Control_Tree_Menu_Init
       ├── MenuOption_create (×5)
       │       ├── 创建菜单选项
       │       ├── 参数：
       │       │   ├── 菜单选项数组
       │       │   ├── 菜单项编号
       │       │   ├── 菜单项描述
       │       │   └── 菜单项对应的处理函数
       │       ├── 处理函数：
       │       │   ├── 返回选择二叉树菜单
       │       │   ├── 插入数值
       │       │   ├── 删除数值
       │       │   ├── 查找数值
       │       │   ├── 打印二叉树
       │       │   ├── 中序遍历
       │       │   ├── 以某值为界限拆分二叉树
       │       │   └── 删除该树
       ├── Menu_Create
       │       ├── 创建菜单结构
       │       ├── 参数：
       │       │   ├── 菜单结构指针
       │       │   ├── 菜单标题
       │       │   ├── 菜单选项数组
       │       │   ├── 菜单选项数量
       │       │   └── 最大选项数量
       └── 返回 STATUS_TRUE
   ```

4. 初始化树菜单及选项

   ```txt
   Tree_Menu_Init
       ├── MenuOption_create (×5)
       │       ├── 创建菜单选项
       │       ├── 参数：
       │       │   ├── 菜单选项数组
       │       │   ├── 菜单项编号
       │       │   ├── 菜单项描述
       │       │   └── 菜单项对应的处理函数
       │       ├── 处理函数：
       │       │   ├── 返回顶级目录
       │       │   ├── 跳转到指定序号平衡二叉树调整菜单
       │       │   └── 查看当前二叉树数量
       ├── Menu_Create
       │       ├── 创建菜单结构
       │       ├── 参数：
       │       │   ├── 菜单结构指针
       │       │   ├── 菜单标题
       │       │   ├── 菜单选项数组
       │       │   ├── 菜单选项数量
       │       │   └── 最大选项数量
       └── 返回 STATUS_TRUE
   ```

5. 初始化更多功能菜单及选项

   ```txt
   More_Menu_Init
       ├── MenuOption_create (×5)
       │       ├── 创建菜单选项
       │       ├── 参数：
       │       │   ├── 菜单选项数组
       │       │   ├── 菜单项编号
       │       │   ├── 菜单项描述
       │       │   └── 菜单项对应的处理函数
       │       ├── 处理函数：
       │       │   ├── 返回顶级目录
       │       │   ├── 打印指定编号的二叉树
       │       │   ├── 合并指定两个编号的二叉树
       │       │   └── 查看当前二叉树的数量
       ├── Menu_Create
       │       ├── 创建菜单结构
       │       ├── 参数：
       │       │   ├── 菜单结构指针
       │       │   ├── 菜单标题
       │       │   ├── 菜单选项数组
       │       │   ├── 菜单选项数量
       │       │   └── 最大选项数量
       └── 返回 STATUS_TRUE
   ```

### 三.7 主程序的流程

1. 变量定义

   * 定义主菜单、树操作菜单、树控制菜单、更多操作菜单 (`top_menu`、`tree_menu`、`control_tree_menu`、`more_menu`)。
   * 定义各个菜单的选项数组 (`top_menu_option`、`tree_menu_option`、`control_tree_menu_option`、`more_menu_option`)。
   * 定义一个链表 (`avl_list`)，用于存储 AVL 树的列表。
   * 定义一个变量 (`now_avl_position`)，表示当前所选择的 AVL 树在链表中的位置，初始值为-1（表示未选择任何树）。
   * 定义当前菜单 (`now_menu`) 和一个上下文处理器 (`context`)。

2. 初始化

   * 初始化链表 `avl_list`，用于存储 AVL 树对象。
   * 初始化主菜单、树操作菜单、树控制菜单和更多操作菜单及其选项。
   * 初始化上下文 `context`，绑定当前菜单和其他菜单，以及 AVL 树链表和当前 AVL 树位置变量。
   * 设置当前菜单为主菜单 `top_menu`。

3. 程序主循环

   * 程序进入主循环，当状态 (`main_status`) 不为 `STATUS_FALSE` 时，持续运行。

   在主循环中执行以下操作：

   * 显示当前菜单
     * 调用 `Menu_Display()` 函数，显示当前菜单的内容。
   * 用户输入
     * 提示用户输入选项。
     * 读取用户输入（使用 `fgets()` 函数），并去除换行符。
   * 处理用户输入
     * 调用 `Menu_HandlerInput()` 函数，根据用户输入处理对应逻辑。
     * 如果输入非法（返回 `STATUS_OVERFLOW`），提示用户输入非法。
   * 暂停程序
     * 提示用户按回车键继续。
   * 清屏
     * 调用 `ClearScreen()` 函数，清除屏幕，准备进入下一轮循环。

4. 程序结束

   * 如果主循环中返回的状态为 `STATUS_FALSE`，程序跳出循环。
   * 打印提示信息“程序发生错误，即将终止”。
   * 等待用户按下回车键后退出程序。

------

## 四. 调试分析

------

### 四.1 调试过程中的问题及解决方法

1. 数据结构的初始化与内存管理问题
   * 问题: 在调试过程中，发现AVL树和链表在初始化或释放内存时偶尔会出现崩溃问题。例如，在`List_RemoveAt`或`Avl_Destroy`调用中，操作未正确完成，导致程序访问非法内存。
   * 解决方法: 通过对代码逻辑逐步检查，发现是因为部分内存没有正确分配或释放，尤其是在创建新树或清空所有树时可能出现问题。针对这一点，我添加了判空逻辑，对指针状态进行了严格的检查，确保内存管理的每一步都有清晰的执行流程。此外，对于`ListElementType`指针，我添加了NULL判断，以避免未初始化的内存操作。
2. 输入验证的边界条件问题
   * 问题: 在用户输入整数值时，未对过长的输入字符串进行正确处理，导致字符串截断或溢出。特别是当用户输入非法字符或超出范围的数字时，程序可能会崩溃或出现不正确的行为。
   * 解决方法: 实现了`Interactor_IsNumber`函数，用于严格检查输入是否为纯数字，并将`fgets`输入内容中的换行符去除。此外，还对数字范围进行了限制，通过`strlen`限制输入长度，并在`Helper_CharInputAndOutputInt`中设置了最大值判断。
3. 菜单跳转逻辑的混乱问题
   * 问题: 在多个菜单之间跳转时，有时`HandlerContext`中`now_menu`未正确更新，导致用户的选择指向了错误的菜单界面。
   * 解决方法: 对每个菜单处理函数增加了对`now_menu`的统一赋值操作，确保菜单切换逻辑的连贯性。同时增加了针对`HandlerContext`的初始化函数`HandlerContext_Init`，在程序启动时对所有菜单指针进行绑定，确保上下文一致性。
4. AVL树操作的逻辑错误
   * 问题: 在实现AVL树操作（如插入、删除、分裂、合并）时，发现部分边界条件没有考虑清楚。例如，在树为空时执行删除或查找操作可能引发崩溃；在合并两棵树时，若任意一棵树为NULL，程序也可能异常退出。
   * 解决方法: 为所有AVL树操作增加了空树的特殊处理逻辑，确保当树为空时能够提示用户，而不是直接操作。此外，对`Avl_Insert`、`Avl_Delete`和`Avl_Merge`函数的返回值进行了详细检查，在每一步操作中增加了错误处理逻辑。

------

### 四.2 对设计与实现的回顾与分析

1. 模块化设计的优点
    整体代码通过模块化设计，将菜单逻辑、AVL树操作、链表管理等功能分离，极大地提高了代码的可读性和可维护性。尤其是将菜单操作抽象成统一的`Menu`结构体及其选项数组，使得新增功能或修改菜单选项变得简单明了。
2. 上下文结构的设计合理性
    使用`HandlerContext`统一管理当前菜单和关联数据，如AVL树列表、当前选中的树编号等，显著简化了跨模块调用的复杂度。这种设计方式有效避免了全局变量的使用，使程序逻辑更加清晰，同时降低了潜在的命名冲突风险。
3. 用户交互的鲁棒性
    在用户输入方面，添加了大量的输入验证逻辑，确保程序能够应对各种异常输入（如非数字、过长字符串、超出范围的数字等）。这一点在实际运行中表现出色，避免了大量的潜在崩溃问题。
4. AVL树功能的扩展性
    设计实现的AVL树模块功能丰富，包括插入、删除、查找、打印、分裂、合并等操作。这些功能在实现时不仅满足了基本需求，还预留了接口，可以在未来方便地扩展更多的平衡树功能，例如范围查询或批量操作。
5. 边界条件的处理仍需改进
    尽管在调试中修复了大部分边界条件问题，但仍有部分逻辑需要进一步优化。例如，在AVL树分裂操作中，如果用户输入的分界值恰好不在树中，可能导致操作逻辑不够直观。未来可以在交互逻辑上进一步优化，例如为用户提供更清晰的提示信息。
6. 用户体验的提升空间
    当前的程序以命令行交互为主，功能虽然齐全，但界面美观性和操作便利性方面仍有改进空间。例如，可以通过图形化界面或更清晰的层级菜单结构，进一步优化用户体验。

------

### 四.3 算法的时空分析

#### 四.3.1. AVL 树初始化

* 函数：`Avl_Init`、`AvlNode_Init`、`AvlNode_InitDefault`
* 时间复杂度：O(1)
  * 初始化树或节点的操作只需要分配空间或设置默认值，时间复杂度为常数。
* 空间复杂度：O(1)
  * 初始化过程中只分配一个节点的内存空间。

#### 四.3.2. AVL 树销毁

* 函数：`Avl_Destroy`
* 时间复杂度：O(n)
  * 每个节点都需要递归地释放左右子树，一共需要访问所有节点，因此复杂度为 O(n)。
* 空间复杂度：O(h)
  * 由于递归调用栈的深度取决于树的高度，AVL 树的高度为 O(\log n)，因此空间复杂度为 O(\log n)。

#### 四.3.3. 旋转操作

###### 3.1 右旋：`Avl_RotateRight`

###### 3.2 左旋：`Avl_RotateLeft`

* 时间复杂度：O(1)
  * 旋转操作只是改变节点的指针指向，并不涉及遍历子树，因此时间复杂度是常数。
* 空间复杂度：O(1)
  * 没有额外的递归或分配。

#### 四.3.4. 计算树的高度

* 函数：`Avl_GetHeight`
* 时间复杂度：O(n)
  * 需要递归访问整棵树中的每个节点来计算高度。
* 空间复杂度：O(h)
  * 递归调用栈深度取决于树的高度，最坏情况下为 O(h)，对于平衡 AVL 树是 O(\log n)。

#### 四.3.5. 更新平衡因子

* 函数：`Avl_UpdateBalanceFactor`
* 时间复杂度：O(n)
  * 每次更新需要递归遍历整棵树，因此时间复杂度为 O(n)。
* 空间复杂度：O(h)
  * 递归调用栈深度为 O(h)，对于平衡树是 O(\log n)。

#### 四.3.6. 插入节点

* 函数：`Avl_Insert`
* 时间复杂度：O(\log n)
  * 插入操作包括两部分：
    1. 按照二叉搜索树的规则找到插入位置，这需要 O(\log n)。
    2. 插入后进行平衡因子的更新和旋转，AVL 树的旋转是常数时间 O(1)。
* 空间复杂度：O(h)
  * 递归调用栈深度为 O(h)，即 O(\log n)。

#### 四.3.7. 删除节点

* 函数：`Avl_Delete`
* 时间复杂度：O(\log n)
  * 删除操作包括三部分：
    1. 按照二叉搜索树的规则找到待删除节点，复杂度为 O(\log n)。
    2. 删除节点后调整平衡因子，复杂度为 O(\log n)。
    3. 旋转操作是常数时间 O(1)。
* 空间复杂度：O(h)
  * 递归调用栈深度为 O(h)，即 O(\log n)。

#### 四.3.8. 查找节点

* 函数：`Avl_Search`
* 时间复杂度：O(\log n)
  * 查找操作在平衡二叉树中沿树高递归，最多需要访问 O(\log n) 个节点。
* 空间复杂度：O(h)
  * 递归调用栈深度为 O(h)，即 O(\log n)。

#### 四.3.9. 中序遍历

* 函数：`Avl_InOrderTraverse`
* 时间复杂度：O(n)
  * 中序遍历需要访问树中所有的节点，因此时间复杂度为 O(n)。
* 空间复杂度：O(h)
  * 递归调用栈深度取决于树的高度，为 O(h)，即 O(\log n)。

#### 四.3.10. 分割 AVL 树

* 函数：`Avl_Split`
* 时间复杂度：O(n)
  * 每个节点会被访问一次并插入到相应的子树，因此复杂度为 O(n)。
* 空间复杂度：O(h)
  * 递归调用栈深度为 O(h)，即 O(\log n)。

#### 四.3.11. 复制 AVL 树

* 函数：`Avl_Copy`
* 时间复杂度：O(n)
  * 每个节点需要递归访问一次，并插入到新的树中。
* 空间复杂度：O(h)
  * 递归调用栈深度为 O(h)，即 O(\log n)。

#### 四.3.12. 合并 AVL 树

* 函数：`Avl_Merge`
* 时间复杂度：O(n + m + (n + m)\log(n + m))
  * 需要先复制两棵树到目标树中（O(n + m)），然后进行插入操作以重新构建平衡树，插入的时间复杂度为 O((n+m)\log(n+m))。
* 空间复杂度：O(h_1 + h_2)
  * 递归调用栈深度取决于两棵树的高度和合并过程中的深度。

#### 四.3.13. 打印 AVL 树

* 函数：`Avl_PrintTree`
* 时间复杂度：O(n)
  * 每个节点需要被访问一次，打印操作是常数时间。
* 空间复杂度：O(h)
  * 递归调用栈深度为 O(h)，即 O(\log n)。

### 四.3.14. 总体复杂度总结

| 操作         | 时间复杂度        | 空间复杂度       |
| ------------ | ----------------- | ---------------- |
| 初始化       | O(1)              | O(1)             |
| 销毁树       | O(n)              | O(log n)         |
| 插入节点     | O(log n)          | O(log n)         |
| 删除节点     | O(log n)          | O(log n)         |
| 查找节点     | O(\log n)         | O(log n)         |
| 中序遍历     | O(n)              | O(log n)         |
| 更新平衡因子 | O(n)              | O(log n)         |
| 高度计算     | O(n)              | O(log n)         |
| 分割树       | O(n)              | O(log n)         |
| 复制树       | O(n)              | O(log n)         |
| 合并树       | O(n + m log(n+m)) | O(log n + log m) |
| 打印树       | O(n)              | O(log n)         |

#### 分析总结

* AVL 树的主要优势是通过严格控制平衡因子，将查找、插入、删除的时间复杂度控制在 O(\log n)。
* 空间复杂度主要受到递归调用栈的影响，最坏情况下为树高 O(\log n)。

------

## 五. 用户使用说明

本程序是一个基于控制台的菜单管理系统，结合了 AVL 树、链表以及多个菜单模块，用于演示菜单选项的交互和处理。

------

### 功能概览

1. 主菜单
   * 提供顶层功能选择入口。
2. AVL 树菜单
   * 对 AVL 树执行增删改查等操作。
3. 控制 AVL 树菜单
   * 提供对 AVL 树的更详细控制功能。
4. 更多选项菜单
   * 包含附加功能。
5. 链表管理
   * 管理 AVL 树对象的链表。

------

### 程序运行环境

* 编译环境：`cmake version 3.25.1`, `mingw 11.0 w64`

* 运行环境：任何支持标准输入输出的终端。

* 依赖文件：

  * `avl_tree.h`
  * `interactor.h`
  * `linked_list.h`
  * `menu.h`
  * `status.h`

------

### 运行方式

1. 确保所有依赖的 `.h` 和实现文件已正确编译。

2. 运行生成的可执行文件。

3. 按照提示进行输入和操作。

------

### 使用指南

#### 1. 主菜单

运行程序后，您将看到主菜单，列出了程序的顶层功能选项。每个选项对应一个数字编号。

* 输入提示：

  ```
  请输入选择: 
  ```

  用户需输入数字以选择对应功能。

* 主菜单选项：

  * 每个菜单选项在程序中均有对应的功能。
  * 如果输入无效，系统会提示输入不合法。

#### 2. 菜单切换

系统包含多层菜单结构，不同菜单负责不同功能模块。通过输入数字，您可以在菜单中导航或切换。

#### 3. 输入要求

* 合法输入：

  * 仅允许输入对应菜单选项的数字编号。
  * 输入必须为纯数字，且范围必须在当前菜单选项编号内。
  
* 无效输入处理：

  * 如果输入为空、超出范围或包含非数字字符，程序将提示输入错误，并要求重新输入。

------

### 常见问题与处理

1. Q: 输入非数字字符时程序如何处理？
    A: 程序会提示输入不合法，并返回主菜单。
2. Q: 输入选项超过菜单范围时会怎样？
    A: 程序会提示输入超出范围，并要求重新输入。
3. Q: 如何退出程序？
    A: 在菜单选项中选择对应的退出功能，或者手动关闭终端。

------

### 开发者说明

#### 程序结构

1. `Menu` 结构体：定义菜单及其选项。
2. `MenuOption` 结构体：每个选项包含文字描述和对应的处理函数。
3. `LinkedList`：用于存储 AVL 树对象。
4. `HandlerContext`：提供上下文数据，用于菜单处理。

#### 重要函数

1. `Menu_Display`：显示当前菜单的所有选项。
2. `Menu_HandlerInput`：处理用户输入，判断是否合法，并调用对应选项的处理函数。
3. `HandlerContext_Init`：初始化上下文数据。

#### 错误处理

* 输入为空、非数字或超出范围时，程序将返回 `STATUS_OVERFLOW`，提示用户重新输入。

------

### 代码扩展

如果需要扩展功能，可以在以下位置添加代码：

1. 新增菜单选项：在对应的 `MenuOption` 数组中添加新选项，并实现处理函数。
2. 处理函数实现：在 `menu.c` 或其他文件中实现新功能逻辑。
3. 数据结构扩展：修改 `LinkedList` 或 AVL 树以支持更多操作。

------

### 注意事项

1. 程序依赖输入正确性，输入错误会导致额外提示和处理时间。
2. 每次菜单切换和操作执行后，需要按回车键继续。

## 六. 测试结果

------

### 六.1 对于单棵二叉树的操作测试

进入程序, 界面如下:

```cmd
顶级菜单
0. 退出程序
1. 创建一棵新平衡二叉树
2. 选择二叉树进行调整
3. 更多功能
4. 自动生成一棵包含所有从起始值到结束值（包括边界值）的平衡二叉树

请输入选择: 
```

输入1, 回车, 界面如下:

```cmd
顶级菜单
0. 退出程序
1. 创建一棵新平衡二叉树
2. 选择二叉树进行调整
3. 更多功能
4. 自动生成一棵包含所有从起始值到结束值（包括边界值）的平衡二叉树

请输入选择: 1
创建成功
按回车以继续
```

回车, 界面如下:

```cmd
顶级菜单
0. 退出程序
1. 创建一棵新平衡二叉树
2. 选择二叉树进行调整
3. 更多功能
4. 自动生成一棵包含所有从起始值到结束值（包括边界值）的平衡二叉树

请输入选择: 
```

输入2, 回车, 界面如下:

```cmd
顶级菜单
0. 退出程序
1. 创建一棵新平衡二叉树
2. 选择二叉树进行调整
3. 更多功能
4. 自动生成一棵包含所有从起始值到结束值（包括边界值）的平衡二叉树

请输入选择: 2
按回车以继续
```

回车后, 界面如下:

```cmd
选择二叉树菜单
0. 返回顶级目录
1. 跳转到指定序号平衡二叉树调整菜单
2. 查看当前二叉树数量

请输入选择: 
```

输入2, 回车, 界面如下:

```cmd
选择二叉树菜单
0. 返回顶级目录
1. 跳转到指定序号平衡二叉树调整菜单
2. 查看当前二叉树数量

请输入选择: 2
当前共有二叉树数量为 1 
按回车以继续
```

回车后输入1, 回车, 界面如下: 

```cmd
选择二叉树菜单
0. 返回顶级目录
1. 跳转到指定序号平衡二叉树调整菜单
2. 查看当前二叉树数量

请输入选择: 1
输入您要查看的二叉树对应的序号:
```

输入1,  回车, 界面如下:

```cmd
单棵平衡二叉树调整菜单
0. 返回选择二叉树菜单
1. 插入数值
2. 删除数值
3. 查找数值
4. 打印二叉树
5. 中序遍历
6. 以某值为界限拆分二叉树
7. 删除该树

请输入选择:
```

输入1, 回车, 输入1, 界面如下:

```cmd
单棵平衡二叉树调整菜单
0. 返回选择二叉树菜单
1. 插入数值
2. 删除数值
3. 查找数值
4. 打印二叉树
5. 中序遍历
6. 以某值为界限拆分二叉树
7. 删除该树

请输入选择: 1
输入要添加的数字: 1
按回车以继续
```

回车,
输入1, 回车, 输入2, 回车.
输入1, 回车, 输入3, 回车.
输入1, 回车, 输入4, 回车
输入1, 回车, 输入5, 回车.
输入4, 回车, 界面如下: 

```cmd
单棵平衡二叉树调整菜单
0. 返回选择二叉树菜单
1. 插入数值
2. 删除数值
3. 查找数值
4. 打印二叉树
5. 中序遍历
6. 以某值为界限拆分二叉树
7. 删除该树

请输入选择: 4
              5(BF: 0)
       4(BF: 0)
              3(BF: 0)
2(BF: -1)
       1(BF: 0)
按回车以继续
```

回车,
输入5, 回车, 界面如下: 

```cmd
单棵平衡二叉树调整菜单
0. 返回选择二叉树菜单
1. 插入数值
2. 删除数值
3. 查找数值
4. 打印二叉树
5. 中序遍历
6. 以某值为界限拆分二叉树
7. 删除该树

请输入选择: 5
1 2 3 4 5 
按回车以继续
```

回车,
输入2, 回车, 输入2, 回车, 界面如下:

```cmd
单棵平衡二叉树调整菜单
0. 返回选择二叉树菜单
1. 插入数值
2. 删除数值
3. 查找数值
4. 打印二叉树
5. 中序遍历
6. 以某值为界限拆分二叉树
7. 删除该树

请输入选择: 2
输入要删除的数字: 2
按回车以继续
```

回车,
输入4, 回车, 界面如下:

```cmd
单棵平衡二叉树调整菜单
0. 返回选择二叉树菜单
1. 插入数值
2. 删除数值
3. 查找数值
4. 打印二叉树
5. 中序遍历
6. 以某值为界限拆分二叉树
7. 删除该树

请输入选择: 4
              5(BF: 0)
       4(BF: -1)
3(BF: -1)
       1(BF: 0)
按回车以继续
```

回车, 
输入3, 回车, 输入1, 回车, 界面如下: 

```cmd
单棵平衡二叉树调整菜单
0. 返回选择二叉树菜单
1. 插入数值
2. 删除数值
3. 查找数值
4. 打印二叉树
5. 中序遍历
6. 以某值为界限拆分二叉树
7. 删除该树

请输入选择: 3
输入要删除的数字: 1
该树存在该值 1 
按回车以继续
```

回车,
输入6, 回车, 
输入3, 回车, 界面如下:

```cmd
单棵平衡二叉树调整菜单
0. 返回选择二叉树菜单
1. 插入数值
2. 删除数值
3. 查找数值
4. 打印二叉树
5. 中序遍历
6. 以某值为界限拆分二叉树
7. 删除该树

请输入选择: 6
输入要作为分割两个平衡二叉树的数字: 3
分割成功
分割的第1棵树:
1(BF: 0)
分割的第2棵树:
       5(BF: 0)
4(BF: -1)
按回车以继续
```

回车, 
输入0, 回车, 菜单如下:

```cmd
选择二叉树菜单
0. 返回顶级目录
1. 跳转到指定序号平衡二叉树调整菜单
2. 查看当前二叉树数量

请输入选择: 
```

输入0, 回车, 菜单如下:
```cmd
顶级菜单
0. 退出程序
1. 创建一棵新平衡二叉树
2. 选择二叉树进行调整
3. 更多功能
4. 自动生成一棵包含所有从起始值到结束值（包括边界值）的平衡二叉树

请输入选择: 
```

输入0, 程序退出成功.

------

### 六.2 对于两棵树的操作测试

进入程序, 界面如下:

```cmd
顶级菜单
0. 退出程序
1. 创建一棵新平衡二叉树
2. 选择二叉树进行调整
3. 更多功能
4. 自动生成一棵包含所有从起始值到结束值（包括边界值）的平衡二叉树

请输入选择: 
```

输入4, 回车,
输入1, 回车,
输入10, 回车, 界面如下:

```cmd
顶级菜单
0. 退出程序
1. 创建一棵新平衡二叉树
2. 选择二叉树进行调整
3. 更多功能
4. 自动生成一棵包含所有从起始值到结束值（包括边界值）的平衡二叉树

请输入选择: 4
输入起始值: 1
输入结束值: 10
生成成功

生成结果: 
                     10(BF: 0)
              9(BF: -1)
       8(BF: 0)
                     7(BF: 0)
              6(BF: 0)
                     5(BF: 0)
4(BF: -1)
              3(BF: 0)
       2(BF: 0)
              1(BF: 0)
按回车以继续
```

回车,
输入4, 回车,
输入1, 回车,
输入10, 回车, 界面如下:

```cmd
顶级菜单
0. 退出程序
1. 创建一棵新平衡二叉树
2. 选择二叉树进行调整
3. 更多功能
4. 自动生成一棵包含所有从起始值到结束值（包括边界值）的平衡二叉树

请输入选择: 4
输入起始值: 10
输入结束值: 20
生成成功

生成结果: 
                     20(BF: 0)
              19(BF: 0)
                     18(BF: 0)
       17(BF: 0)
                     16(BF: 0)
              15(BF: 0)
                     14(BF: 0)
13(BF: -1)
              12(BF: 0)
       11(BF: 0)
              10(BF: 0)
按回车以继续
```

回车,
输入3, 回车, 回车, 界面如下:

```cmd
更多功能菜单
0. 返回顶级目录
1. 打印指定编号的二叉树
2. 合并指定两个编号的二叉树
3. 查看当前二叉树的数量

请输入选择: 
```

输入3, 回车, 界面如下:

```cmd
更多功能菜单
0. 返回顶级目录
1. 打印指定编号的二叉树
2. 合并指定两个编号的二叉树
3. 查看当前二叉树的数量

请输入选择: 3
当前共有二叉树数量为 2 
按回车以继续
```

回车, 
输入1, 回车,
输入1, 回车, 
界面如下:

```cmd
更多功能菜单
0. 返回顶级目录
1. 打印指定编号的二叉树
2. 合并指定两个编号的二叉树
3. 查看当前二叉树的数量

请输入选择: 1
输入您要查看的二叉树对应的序号: 1
                     10(BF: 0)
              9(BF: -1)
       8(BF: 0)
                     7(BF: 0)
              6(BF: 0)
                     5(BF: 0)
4(BF: -1)
              3(BF: 0)
       2(BF: 0)
              1(BF: 0)
按回车以继续
```

回车, 
输入1, 回车,
输入2, 回车, 
界面如下:

```cmd
更多功能菜单
0. 返回顶级目录
1. 打印指定编号的二叉树
2. 合并指定两个编号的二叉树
3. 查看当前二叉树的数量

请输入选择: 1
输入您要查看的二叉树对应的序号: 2
                     20(BF: 0)
              19(BF: 0)
                     18(BF: 0)
       17(BF: 0)
                     16(BF: 0)
              15(BF: 0)
                     14(BF: 0)
13(BF: -1)
              12(BF: 0)
       11(BF: 0)
              10(BF: 0)
按回车以继续
```

回车, 
输入2, 回车,
输入1, 回车,
输入2, 回车, 界面如下:

```cmd
更多功能菜单
0. 返回顶级目录
1. 打印指定编号的二叉树
2. 合并指定两个编号的二叉树
3. 查看当前二叉树的数量

请输入选择: 2
输入您要合并的第1棵二叉树对应的序号: 1
输入您要合并的第2棵二叉树对应的序号: 2
合并成功

参与合并的第1棵树: 
                     10(BF: 0)
              9(BF: -1)
       8(BF: 0)
                     7(BF: 0)
              6(BF: 0)
                     5(BF: 0)
4(BF: -1)
              3(BF: 0)
       2(BF: 0)
              1(BF: 0)

参与合并的第2棵树: 
                     20(BF: 0)
              19(BF: 0)
                     18(BF: 0)
       17(BF: 0)
                     16(BF: 0)
              15(BF: 0)
                     14(BF: 0)
13(BF: -1)
              12(BF: 0)
       11(BF: 0)
              10(BF: 0)

合并结果: 
                            20(BF: 0)
                     19(BF: -1)
              18(BF: -1)
                     17(BF: 0)
       16(BF: 0)
                            15(BF: 0)
                     14(BF: 0)
                            13(BF: 0)
              12(BF: 0)
                            11(BF: 0)
                     10(BF: 0)
                            9(BF: 0)
8(BF: -1)
                     7(BF: 0)
              6(BF: 0)
                     5(BF: 0)
       4(BF: 0)
                     3(BF: 0)
              2(BF: 0)
                     1(BF: 0)
```

回车, 
输入0, 回车, 回车,
输入0, 回车, 程序结束

------

## 七. 附录

------

```cmd
│   .clang-format
│   CMakeLists.txt
│
├───inc
│       avl_tree.h
│       interactor.h
│       linked_list.h
│       menu.h
│       status.h
│
├───src
│       avl_tree.c
│       interactor.c
│       linked_list.c
│       main.c
│       menu.c
│
└───test
        test_avl_tree.c
        test_int_linked_list.c
        test_menu.c
```
